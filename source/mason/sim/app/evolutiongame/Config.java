package sim.app.evolutiongame;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.internal.LinkedTreeMap;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileFilter;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.app.evolutiongame.Util.Pair;
import sim.app.evolutiongame.modules.Module;

/**
 *
 * @author Ben Armstrong
 */
public class Config {
    
    private static final String FILE_NAME = "config.json";
    private static final String MODULE_PACKAGE = "sim.app.evolutiongame.modules";
    private static final String MODULE_PATH = "source/mason/sim/app/evolutiongame/modules";
    
    /***** The list of sections in the outputted configuration file. *******/
    
    /**
     * This section contains a list of all module names pointing at:
     *  1) A list of the names of all implementations of the module
     *  2) A list of the arguments that the default implementation of the module
     *  says are required.
     */
    public static final String ALL_MODULES = "All Modules";
    /**
     * The names of modules and module implementations that will be run on each
     * player, in the order that they will be run.
     */
    public static final String MODULES_TO_RUN = "Modules To Run (Ordered)";
    /**
     * The list of modules pointing at implementations that should be run when
     * a specific module is run, not at the time specified in MODULES_TO_RUN.
     */
    public static final String PREFERRED_IMPLEMENTATIONS = "Preferred Implementations";
    
    /**
     * From the list of modules generated by findModuleImplementations(), this 
     * method will create/overwrite the json configuration file in the root
     * project directory.
     * Currently the config file consists of a list of implementations of each
     * module and a list of which implementation to use for each module. The
     * default config file will use all modules that have at least one
     * implementation. 
     */
    public static void generateConfigFile() {
        
        LinkedHashMap<String, ArrayList<String>> moduleImplementations = findModuleImplementations();
        LinkedHashMap<String, String> defaults = getDefaultImplementations(moduleImplementations);
        LinkedHashMap<String, String[]> arguments = getArguments(moduleImplementations.keySet());
        
        LinkedHashMap<String, LinkedHashMap<String, Object>> modules = new LinkedHashMap<>();
        for(String moduleName: moduleImplementations.keySet()){
            LinkedHashMap<String, Object> tmp = new LinkedHashMap<>();
            tmp.put("Implementations", moduleImplementations.get(moduleName));
            tmp.put("Arguments", arguments.get(moduleName));
            modules.put(moduleName, tmp);
        }
        
        //use a LinkedHashMap to preserve order (which keeps the output file in
        //a more readable format).
        LinkedHashMap<String, Object> output = new LinkedHashMap<>();
        output.put(ALL_MODULES, modules);
        output.put(MODULES_TO_RUN, defaults);
        
        //PREFERRED_IMPLEMENTATIONS should contain every module
        output.put(PREFERRED_IMPLEMENTATIONS, defaults);
        
        Gson gson = new GsonBuilder().setPrettyPrinting().create();
        try (FileWriter writer = new FileWriter(FILE_NAME)) {
          writer.write(gson.toJson(output));
        } catch (IOException e) {
            System.err.println(e.getMessage());
        }
    }
    
    /**
     * Finds a list of all java classes that are in each module subdirectory.
     * Associates with each module the classes under it.
     * Ex: If /modules contains folders "play" and "move", with classes "play1",
     * "play2", "move1", "move2" then this will return a map of "play" -> {play1, play2},
     * "move" -> {move1, move2}.
     * This will likely assume that /modules contains only folders and that each
     * folder within /modules contains only files providing an implementation
     * of that module.
     * @return 
     */
    public static LinkedHashMap<String, ArrayList<String>> findModuleImplementations() {
        FileFilter folderFilter = new FileFilter() {
            @Override
            public boolean accept(File pathname){
                return pathname.isDirectory();
            }};
        FileFilter fileFilter = new FileFilter() {
            @Override
            public boolean accept(File pathname){
                return pathname.isFile();
            }};
        
        File folder = new File(MODULE_PATH);
        
        LinkedHashMap<String, ArrayList<String>> map = new LinkedHashMap<>();
        ArrayList<String> implementations = null;
        String s = folder.getAbsolutePath();
        
        for(File module: folder.listFiles(folderFilter)) {
            for(File implementation: module.listFiles(fileFilter)) {
                if(implementations == null)
                    implementations = new ArrayList<>();
                implementations.add(implementation.getName().replace(".java", ""));
            }
            if(implementations != null) {
                map.put(module.getName(), implementations);
                implementations = null;
            }
            
        }
        
        return map;
    }
    
    /**
     * Gets the name of the default implementation of each module given to it.
     * The default name is the implementation that has the same name as the 
     * module, or if that doesn't exist, the first implementation listed.
     * @param modules
     * @return A map of module names to the default implementation of that module.
     */
    private static LinkedHashMap<String, String> getDefaultImplementations(HashMap<String, ArrayList<String>> modules){
        
        LinkedHashMap<String, String> defaults = new LinkedHashMap<>();
        
        for(String module_name: modules.keySet()) {
            ArrayList<String> implementations = (ArrayList<String>)modules.get(module_name);
            
            for(String implementation: implementations) {
                if(implementation.equalsIgnoreCase(module_name)) {
                    defaults.put(module_name, implementation);
                    break;
                }
            }
            if(!defaults.containsKey(module_name) && implementations.size() > 0)
                defaults.put(module_name, implementations.get(0));
        }
        
        
        return defaults;
    }
    
    /**
     * Reads in the config file and puts it into a hashmap.
     * @param p
     * @return 
     */
    public static HashMap<String, Object> readConfigFile(Population p) {
        Gson gson = new Gson();
        
        HashMap<String, Object> configElements = new HashMap<>();
        try (BufferedReader reader = new BufferedReader(new FileReader(FILE_NAME))) {
              configElements = gson.fromJson(reader, HashMap.class);
        } catch (FileNotFoundException e) {
            System.out.println("Finised with JSON examples now.");
        } catch (IOException e) {
            System.out.println("Finised with JSON examples now.");
        }
        
        return configElements;
    }

    /**
     * Generates a list of all methods that should be run for each player in
     * each time step. Methods should all have the signature:
     *  public static void run(Population state, Player p)
     * The classes that the methods are in should be specified in the
     * configuration file.
     * @param modules
     * @return 
     */
    public static LinkedHashMap<String, Pair<Module, Method>> getMethods(LinkedTreeMap<String, String> modules) {
        
        LinkedHashMap<String, Pair<Module, Method>> methods = new LinkedHashMap<>();
        
        for(String module: modules.keySet()) {
            Class c = null;
            try {
                c = Class.forName(MODULE_PACKAGE+"."+module+"."+modules.get(module));

            } catch (ClassNotFoundException ex) {
                Logger.getLogger(Population.class.getName()).log(Level.SEVERE, null, ex);
            }
            
            Method m;
            try {
                m = c.getMethod("run", Population.class, Player.class);
                methods.put(module, new Pair<>((Module)c.newInstance(), m));
            } catch (NoSuchMethodException ex){
                System.out.println("No run() method found in " + c.toString());
            } catch(SecurityException ex) {
                Logger.getLogger(Population.class.getName()).log(Level.SEVERE, null, ex);
            } catch (InstantiationException ex) {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IllegalAccessException ex) {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        return methods;
    }

    /**
     * Use reflection to retrieve the value of the "args" String array in each 
     * module class. This relies on the default class for each module, the 
     * module implementation with the same name as the module itself.
     * @param modules
     * @return 
     */
    public static LinkedHashMap<String, String[]> getArguments(Set<String> modules)
    {
        LinkedHashMap<String, String[]> arguments = new LinkedHashMap<>();
        
        for(String module: modules) {
            Class c = null;
            try {
                c = Class.forName(MODULE_PACKAGE+"."+module+"."+module);
                Field field = c.getDeclaredField("args");
                String[] args = (String[])field.get(null); //can be null since args should be static
                arguments.put(module, args);
            } catch (NoSuchFieldException ex)
            {
                //This will occur if someone simply forgets to add the args 
                //array to their module.  This is not a big deal, it just means
                //their are no arguments. Add an empty array to indicate this.
                arguments.put(module, new String[]{});
                
            } catch (ClassNotFoundException ex) {
                Logger.getLogger(Population.class.getName()).log(Level.SEVERE, null, ex);
            } catch (SecurityException ex)
            {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IllegalArgumentException ex)
            {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            } catch (IllegalAccessException ex)
            {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            } catch (Exception ex)
            {
                Logger.getLogger(Config.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        
        return arguments;
    }
}
